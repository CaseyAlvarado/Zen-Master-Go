
	  <lid>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Zen-master-go by CaseyAlvarado</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="home"><a href="http://caseyalvarado.github.io/Zen-Master-Go/">Home</a></li>
          <li class="design"><a href="http://caseyalvarado.github.io/Zen-Master-Go/design.html">Design</a></li>
          <li class="fork"><a href="https://github.com/CaseyAlvarado/Zen-Master-Go">GitHub Repo</a></li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Othello AI</h1>
          <p>Software Design Final Project</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/CaseyAlvarado">Casey Alvarado</a>, <a href="https://github.com/Pratool">Pratool Gadtaula</a>, and <a href="https://github.com/jaywoo1123">Jay Woo</a></span>
        </div>

<h3>Project Design</h3>
<p>We had decided on a game, Go, that required orders of magnitude more computation than chess when relying on the computer to decide on a move. In order to work out an algorithm, we needed to either completely separate the algorithm from the game or try the algorithm on simpler games.</p> 
<p>If we had completely separated the AI algorithms from a game implementation, the algorithm would be easier to analyze on an abstract level. Going from pseudo-code to Python would also be more intuitive. However, it would require a lot of scaffolding in code in order to test.</p> 
<p>If we use the same AI algorithms, but on simpler games, such as Tic-Tac-Toe, the testing scaffold would be built. However, difficulty arises when integrating an algorithm with previously written code and adapting an algorithm to the rules of specific games.</p>
<p>In the end, we decided to be more goal oriented and decided to try the AI algorithms on simpler games, including Tic-Tac-Toe and Othello, and move up to a Go implementation, since making a useable AI aligned more with our learning goals. This required a redesigning of our project proposal so that our minimum deliverable, a working AI for Go, would not be our barely tangible final deliverable.</p>
<p>We decided to split the work amongst ourselves. Each team member researched AI algorithms that interested us in an effort to learn about and implement the algorithm. Amongst all three of us, we are exploring and applying Markov Chains, Monte Carlo Tree Searches, Rapid Action Value Estimator (RAVE), David Rutland Methods, Neural Networks, and Genetic Algorithms. Once we have working implementations of each algorithm on different games, we will teach each other our algorithms and perhaps play our AIs against each other.</p>
<p>Instead of implementing the methods we were exploring from before (Markov Chains, Monte Carlo Tree Searches, etc.), we stuck with using MiniMax, a basic algorithm that uses the best possible opponent's move to determine the best move possible for the computer by minimizing the opponent's maximum value. After successfully incorporating this idea inefficiently but conceptually accurately in Tic-Tac-Toe, we moved on to a more efficient calculating in Othello. In Othello, the “value” of the board, with respect to the computer, is calculated by multiplying each of the pieces by the effectiveness of their current position. This effectiveness is a weight given to a certain tile on the board. This mimics the Roxanne method of laying out an Othello board, according to page 15 of <a href="http://undergraduate.csse.uwa.edu.au/year4/Current/Students/Files/2007/RyanArcher/CorrectedDissertation.pdf">this dissertation</a>. The board is laid out with priorities set below:</p>
<img src="./images/roxanne-othello.png">
<p>The weights assigned to each space is the difference between 6 and the priority number. This was done so that the factor that each player's piece is multiplied by could be used directly to calculate the score. For instance, the corners were assigned a value of 5, the most weight, since they have the highest priority.</p>
<p>We used pseudo-code that we had found <a href="http://cs.brown.edu/courses/cs015/help_sessions/Othello_Help_Session.pdf">here</a> to help us understand a version of Mihelp us understand a version of MiniMax called NegaMax that effectively returns the same result as MiniMax, but maximizes the negation of the opponent's score.</p>
<p>After numerous hard-to-find bugs in our code, we were able to successfully implement MiniMax. Currently MiniMax works effectively up to four plies, or four turns, ahead. It takes a bit of time to compute, but not enough that the computer hangs or that the human player becomes bored. However, even more plies can be reached by implementing alpha-beta pruning.</p>
<p>Essentially, alpha-beta pruning reduces the number of branches that the computer searches through by eliminating the ones that definitely will not yield good results. By eliminating these branches, greater depths can be reached because the number of branches at each depth decreases significantly.</p>


<h3>MiniMax and NegaMax</h3>
<p>As we developed code for our Othello AI, we discovered that it would be relatively easy to implement NegaMax, which is essentially a different way of representing the MiniMax function. NegaMax simplifies the issue of alternating between finding the branch with the lowest score (for the opponent) and finding the branch with the highest score (for the player), by first picking the branch with the highest value and negating that number.</p>
<img src = "./images/negamax2.jpg" width="80%" style="margin-bottom:15px;">
<p>As shown in this diagram, MiniMax recurses through each node by first calculating the heuristic values at the very bottom of the tree. Then those values propagate upwards, such that the square nodes pick the smallest value while the circular nodes pick the largest value. This requires a big 'if-else' statement in which the if block looks extremely similar to the else block. Rather than having such repetitive code, we combined the if and else blocks together. This also meant that at each depth, we had to negate each value, as shown below. This is how the NegaMax function works:</p>
<img src = "./images/negamax.png" width="80%" style="margin-bottom:15px;">
<p>Each node will always seek the value that is the highest and then negates it for each higher depth.</p>
</section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
